# JEP 424：外部函数和内存API（预览）

- 所有者
    - Maurizio Cimadamore
- 类型
    - Feature
- 范围
    - SE
- 状态
    - 关闭 / 已发布
- 发行版
    - 19
- 组件
    - core-libs
- 讨论
    - panama dash dev at openjdk dot java dot net
- 关联
    - JEP 419: Foreign Function & Memory API (Second Incubator)
    - JEP 412: Foreign Function & Memory API (Incubator)
    - JEP 434: Foreign Function & Memory API (Second Preview)
- 复核
    - Alex Buckley, John Rose, Paul Sandoz
- 通过
    - Brian Goetz, Paul Sandoz
- 创建
    - 2022/02/17 10:19
- 更新
    - 2022/12/14 16:47
- 问题
    - 8282048

# 摘要

引入一个API，通过该API，Java程序可以与Java运行时之外的代码和数据进行互操作。
通过有效地调用外部函数（即JVM外部的代码）和安全地访问外部内存（即不由JVM管理的内存），
API使Java程序能够调用本机库并处理本机数据，而不会像JNI那样脆弱和危险。
这是一个预览版 API。

# 历史

外部函数和内存API（FFM）结合了两个早期的孵化API：外部内存访问API（JEP 370，383和393）和外部链接器API（JEP 389）。
该API通过JEP 412在JDK 17中孵化，并通过JEP 419在JDK 18中重新孵化。
该JEP根据FFM API作为孵化API期间的反馈进行了改进。
在JDK 19中，外部函数和内存API不再孵化，相反，它是一个预览API。

# 目标

- 易用性：将Java本机接口（JNI）替换为卓越的纯Java开发模型
- 性能：提供与现有API（如JNI和`sun.misc.Unsafe`）相当（如果不是更好的话）的性能
- 通用性：提供对不同类型的外部内存（例如，本机内存、持久内存和托管堆内存）进行操作的方法，
  并随着时间的推移，适应其他平台（例如，32位 x86）和用 C 以外的语言编写的外部函数（例如，C++、Fortran）
- 安全：允许程序对外来内存执行不安全的操作，但默认情况下警告用户此类操作

# 非目标

这些不是目标

- 在此 API 之上重新实现 JNI，或以其他方式以任何方式更改 JNI
- 在此 API 之上重新实现遗留的 Java API，例如 `sun.misc.Unsafe`
- 提供从本机代码头文件机械生成 Java 代码的工具
- 更改与本机库交互的 Java 应用程序的打包和部署方式（例如，通过多平台 JAR 文件）

# 动机

Java 平台一直为希望超越 JVM 并与其他平台交互的库和应用程序开发人员提供丰富的基础。
Java API 方便可靠地公开非 Java 资源，访问远程数据 （JDBC）， 调用 Web 服务（HTTP 客户端）、
服务远程客户端（NIO 通道）或与本地进程通信（Unix 域套接字）。
不幸的是，Java 开发人员在访问一种重要的非 Java 资源时仍然面临重大障碍：
代码和数据与 JVM 位于同一台机器上，但在 Java 运行时之外。

# 外部内存

存储在 Java 运行时外部内存中的数据称为堆外数据（堆是 Java 对象在堆上存储数据的地方，也是垃圾回收器工作的地方)。
访问堆外数据对于流行的Java库（如Tensorflow，Ignite，Lucene和Netty）的性能至关重要，
主要是因为它可以避免与垃圾收集相关的成本和不可预测性。
它还允许通过映射文件到内存中来序列化和反序列化数据结构，例如 `mmap`。
但是，Java 平台没有提供访问堆外数据的令人满意的解决方案。

ByteBuffer API 允许创建堆外分配的直接字节缓冲区，
但它们的最大大小为 2 GB，并且不会立即解除分配。
这些和其他限制源于这样一个事实，
即 ByteBuffer API 不仅设计用于堆外内存访问，还设计用于字符集编码/解码和部分 I/O 操作等领域批量数据的生产者/消费者交换。
在这种情况下，无法满足多年来提出的许多堆外增强请求（例如，4496703、6558368、4837564和5029431）。

`sun.misc.Unsafe` API 公开堆上数据的内存访问操作，这些操作也适用于堆外数据。
使用 Unsafe 非常高效，因为它的内存访问操作被定义为 HotSpot JVM 内部函数，并由 JIT 编译器进行优化。
但是，使用 Unsafe 很危险，因为它允许访问任何内存位置。
这意味着 Java 程序可以通过访问已释放的位置使 JVM 崩溃;
由于这个原因和其他原因，一直强烈不鼓励使用不安全。

使用 JNI 调用本机库，然后访问堆外数据是可能的，
但性能开销很少使其适用：
从 Java 到本机比访问内存慢几个数量级，因为 JNI 方法调用无法从许多常见的 JIT 优化（如内联）中受益。

综上所述，
在访问堆外数据时，
Java 开发人员面临两难境地：
他们应该选择安全但低效的路径（ByteBuffer），还是应该放弃安全性而支持性能（不安全）？
他们实际上需要一个受支持的 API，用于访问堆外数据（即外部内存），从头开始设计为安全并考虑 JIT 优化。

# 外部函数

JNI从Java 1.1开始支持调用本机代码（即外部函数），但由于许多原因，这是不够的。

- JNI涉及几个乏味的工件：
  一个Java API（本机方法），一个派生自Java API的C头文件，以及调用感兴趣的本机库的 C 实现。
  Java 开发人员必须跨多个工具链工作，以保持依赖于平台的工件同步，当本机库快速发展时，这尤其繁重。
- JNI只能与库的编写语言进行互操作，通常是 C 和 C++，它们使用为其构建 JVM 的操作系统和 CPU 的调用约定。
  本机方法不能用于调用使用不同约定的语言编写的函数。
- JNI 不协调 Java 类型系统与 C 类型系统。
  Java 中的聚合数据用对象表示，但 C 中的聚合数据用结构表示，
  因此，传递给本机方法的任何 Java 对象都必须由本机代码费力地解压缩。
  例如，考虑 Java 中的记录类 Person ：
  将 Person 对象传递给本机方法将需要本机代码使用 JNI 的 C API 从对象中提取字段（例如，firstName 和 lastName）。
  因此，Java 开发人员有时会将数据平展为单个对象（例如，字节数组或直接字节缓冲区），
  但更常见的是，由于通过 JNI 传递 Java 对象很慢，
  他们使用 Unsafe API 来分配堆外内存，并将其地址作为 long 传递给本机方法 — 这使得 Java 代码非常不安全！

多年来，
已经出现了许多框架来填补JNI留下的空白，
包括JNA，JNR和JavaCPP。
虽然这些框架通常比 JNI 有明显的改进，情况仍然不太理想，特别是与提供一流本地互操作的语言相比。
例如，Python 的 `ctypes` 包可以在没有任何胶水代码的情况下动态包装原生库中的函数。
其他语言，如 Rust，提供了从 C/C++ 头文件机械派生本机包装器的工具。

最终
Java 开发人员应该有一个受支持的 API，允许他们直接使用任何被认为对特定任务有用的本机库，
没有 JNI 的繁琐胶水和笨重。
一个很好的抽象是方法句柄，在 Java 7 中引入以支持 JVM 上的快速动态语言。
通过方法句柄公开本机代码将从根本上简化编写、构建和分发依赖于本机库的 Java 库的任务。
此外，能够对外部函数（即本机代码）和外部内存（即堆外数据）进行建模的 API 将为第三方本机互操作框架提供坚实的基础。

# 描述

外部函数和内存 API（FFM API） 定义了类和接口，以便库和应用程序中的客户端代码可以：
分配外部内存（`MemorySegment`、`MemoryAddress`、`SegmentAllocator`），
操作和访问结构化外部内存（`MemoryLayout`、`VarHandle`），
控制外部内存的分配和释放（`MemorySession`），
和调用外部函数（`Linker`、`FunctionDescriptor`、`SymbolLookup`）。
FFM API 驻留在 `java.base` 模块的 `java.lang.foreign` 包中。

# 例子

作为使用FFM API 的简要示例，
下面是 Java 代码，它获取 C 库函数 `radixsort` 的方法句柄，
然后使用它对四个字符串进行排序，这些字符串在 Java 数组中开始生命周期（省略了一些细节）。

由于 FFM API 是预览版 API，因此必须在启用预览功能的情况下编译和运行代码。
即`javac --Release 19 --enable-preview ...`和`Java --enable-preview ...`

```
// 1. Find foreign function on the C library path
Linker linker = Linker.nativeLinker();
SymbolLookup stdlib = linker.defaultLookup();
MethodHandle radixSort = linker.downcallHandle(stdlib.lookup("radixsort"), ...);

// 2. Allocate on-heap memory to store four strings
String[] javaStrings = { "mouse", "cat", "dog", "car" };

// 3. Allocate off-heap memory to store four pointers
SegmentAllocator allocator = SegmentAllocator.implicitAllocator();
MemorySegment offHeap = allocator.allocateArray(ValueLayout.ADDRESS, javaStrings.length);

// 4. Copy the strings from on-heap to off-heap
for (int i = 0; i < javaStrings.length; i++) {
  // Allocate a string off-heap, then store a pointer to it
  MemorySegment cString = allocator.allocateUtf8String(javaStrings[i]);
  offHeap.setAtIndex(ValueLayout.ADDRESS, i, cString);
}

// 5. Sort the off-heap data by calling the foreign function
radixSort.invoke(offHeap, javaStrings.length, MemoryAddress.NULL, '\0');

// 6. Copy the (reordered) strings from off-heap to on-heap
for (int i = 0; i < javaStrings.length; i++) {
  MemoryAddress cStringPtr = offHeap.getAtIndex(ValueLayout.ADDRESS, i);
  javaStrings[i] = cStringPtr.getUtf8String(0);
}

assert Arrays.equals(javaStrings, new String[] {"car", "cat", "dog", "mouse"}); // true
```

此代码比任何使用 JNI 的解决方案都清晰得多，
因为隐藏在本机方法调用后面的隐式转换和内存取消引用现在直接在 Java 中表示。
也可以使用现代Java习惯，例如，流可以允许多个线程在堆内存和堆外内存之间并行复制数据。

# 内存段

A memory segment is an abstraction that models a contiguous region of memory,
located either off-heap or on-heap. Memory segments can be

Native segments, allocated from scratch in native memory (e.g., via malloc),
Mapped segments, wrapped around a region of mapped native memory (e.g., via mmap), or
Array or buffer segments, wrapped around memory associated with existing Java arrays or byte buffers, respectively.
All memory segments provide strongly enforced spatial, temporal, and thread-confinement guarantees which make memory
dereference operations safe. For example, the following code allocates 100 bytes off-heap:

MemorySegment segment = MemorySegment.allocateNative(100,
MemorySession.openImplicit());
The spatial bounds of a segment determine the range of memory addresses associated with the segment. The bounds of the
segment in the code above are defined by a base address b, expressed as a MemoryAddress instance, and a size in bytes (
100), resulting in a range of addresses from b to b + 99, inclusive.

The temporal bounds of a segment determine the lifetime of the segment, that is, when the segment will be deallocated. A
segment's lifetime and thread-confinement state is modeled by a MemorySession abstraction, discussed below. The memory
session in the code above is a new implicit session, which ensures that the memory associated with this segment is freed
when the MemorySegment object is deemed unreachable by the garbage collector. The implicit session also ensures that the
memory segment is accessible from multiple threads.

In other words, the code above creates a segment whose behavior closely matches that of a ByteBuffer allocated with the
allocateDirect factory. The FFM API also supports deterministic memory release and other thread-confinement options,
discussed below.

# 取消引用段

To dereference some data in a memory segment, we need to take into account several factors:

The number of bytes to be dereferenced,
The alignment constraints of the address at which dereference occurs,
The endianness with which bytes are stored in said memory region, and
The Java type to be used in the dereference operation (e.g., int vs float).
All these characteristics are captured in the ValueLayout abstraction. For example, the predefined JAVA_INT value layout
is four bytes wide, is aligned on four-byte boundaries, uses the native platform endianness (e.g., little-endian on
Linux/x64), and is associated with the Java type int.

Memory segments have simple dereference methods to read and write values from and to memory segments. These methods
accept a value layout, which uniquely specifies the properties of the dereference operation. For example, we can write
25 int values at consecutive offsets in a memory segment using the following code:

MemorySegment segment = MemorySegment.allocateNative(100,
MemorySession.openImplicit());
for (int i = 0; i < 25; i++) {
segment.setAtIndex(ValueLayout.JAVA_INT,
/* index */ i,
/* value to write */ i);
}

# 内存布局和结构访问

Consider the following C declaration, which defines an array of Point structs, where each Point struct has two members,
namely Point.x and Point.y:

struct Point {
int x;
int y;
} pts[10];
Using the dereference methods shown in the previous section, to initialize such a native array we would have to write
the following code:

MemorySegment segment = MemorySegment.allocateNative(2 * 4 * 10,
MemorySession.openImplicit());
for (int i = 0; i < 10; i++) {
segment.setAtIndex(ValueLayout.JAVA_INT,
/* index */ (i * 2),
/* value to write */ i); // x
segment.setAtIndex(ValueLayout.JAVA_INT,
/* index */ (i * 2) + 1,
/* value to write */ i); // y
}
To reduce the need for tedious calculations about memory layout (e.g., (i * 2) + 1 in the example above), a MemoryLayout
can be used to describe the content of a memory segment in a more declarative fashion. For example, the desired layout
of the native memory segment in the examples above can be described in the following way:

SequenceLayout ptsLayout
= MemoryLayout.sequenceLayout(10,
MemoryLayout.structLayout(
ValueLayout.JAVA_INT.withName("x"),
ValueLayout.JAVA_INT.withName("y")));
This creates a sequence memory layout containing ten repetitions of a struct layout whose elements are two JAVA_INT
layouts named x and y, respectively. Given this layout, we can avoid calculating offsets in our code by creating two
memory-access var handles, special var handles which accept a MemorySegment parameter (the segment to be dereferenced)
followed by one or more long coordinates (the indices at which the dereference operation should occur):

VarHandle xHandle // (MemorySegment, long) -> int
= ptsLayout.varHandle(PathElement.sequenceElement(),
PathElement.groupElement("x"));
VarHandle yHandle // (MemorySegment, long) -> int
= ptsLayout.varHandle(PathElement.sequenceElement(),
PathElement.groupElement("y"));

MemorySegment segment = MemorySegment.allocateNative(ptsLayout,
MemorySession.openImplicit());
for (int i = 0; i < ptsLayout.elementCount().getAsLong(); i++) {
xHandle.set(segment,
/* index */ (long) i,
/* value to write */ i); // x
yHandle.set(segment,
/* index */ (long) i,
/* value to write */ i); // y
}
The ptsLayout object drives the creation of the memory-access var handle through the creation of a layout path, which is
used to select a nested layout from a complex layout expression. Since the selected value layout is associated with the
Java type int, the type of the resulting var handles xHandle and yHandle will also be int. Moreover, since the selected
value layout is defined inside a sequence layout, the var handles acquire an extra coordinate of type long, namely the
index of the Point struct whose coordinate is to be read or written. The ptsLayout object also drives the allocation of
the native memory segment, which is based upon size and alignment information derived from the layout. Offset
computations are no longer needed inside the loop since distinct var handles are used to initialize the Point.x and
Point.y elements.

# 内存会话

All of the examples above use non-deterministic deallocation: The memory associated with the allocated segments is
deallocated by the garbage collector after the memory segment instance becomes unreachable. We say that such segments
are implicitly deallocated.

There are cases where the client might want to control when memory deallocation occurs. Suppose, e.g., that a large
memory segment is mapped from a file using MemorySegment::map. The client might prefer to release (i.e., unmap) the
memory associated with the segment as soon as the segment is no longer required rather than wait for the garbage
collector to do so, since waiting could adversely affect the application's performance.

Memory segments support deterministic deallocation through memory sessions. A memory session models the lifecycle of one
or more memory segments. A newly-created memory session is in the alive state, which means that all the segments it
manages can be accessed safely. At the client's request a memory session can be closed so that access to the segments
managed by the session is no longer allowed. The MemorySession class implements the AutoCloseable interface so that
memory sessions work with the try-with-resources statement:

try (MemorySession session = MemorySession.openConfined()) {
MemorySegment s1 = MemorySegment.map(Path.of("someFile"),
0, 100000,
MapMode.READ_WRITE, session);
MemorySegment s2 = MemorySegment.allocateNative(100, session);
...
} // both segments released here
This code creates a memory session and uses it to create two segments: a mapped segment (s1) and a native segment (s2).
The lifecycle of the two segments is tied to the lifetime of the memory session, so accessing the segments (e.g.,
dereferencing them with memory-access var handles) outside of the try-with-resources statement will cause a runtime
exception to be thrown.

In addition to managing a memory segment's lifetime, a memory session also controls which threads can access the
segment. A confined memory session restricts access to the thread which created the session, whereas a shared memory
session allows access from any thread.

Memory sessions, whether confined or shared, can be associated with a java.lang.ref.Cleaner object that performs
implicit deallocation in case the memory session becomes unreachable while the session is still alive, thus preventing
accidental memory leaks.

# 段分配

Memory allocation can often be a bottleneck when clients use off-heap memory. The FFM API therefore includes a
SegmentAllocator abstraction, which defines useful operations to allocate and initialize memory segments. Segment
allocators are obtained via factories in the SegmentAllocator interface. One such factory returns the implicit
allocator, that is, an allocator which allocates native segments backed by a fresh implicit session. Other, more
optimized allocators are also provided. For example, the following code creates an arena-based allocator and uses it to
allocate a segment whose content is initialized from a Java int array:

try (MemorySession session = MemorySession.openConfined()) {
SegmentAllocator allocator = SegmentAllocator.newNativeArena(session);
for (int i = 0 ; i < 100 ; i++) {
MemorySegment s = allocator.allocateArray(JAVA_INT,
new int[] { 1, 2, 3, 4, 5 });
...
}
...
} // all memory allocated is released here
This code creates a confined memory session and then creates an unbounded arena allocator associated with that session.
This allocator allocates a segment of memory and responds to allocation requests by returning slices of that
pre-allocated segment. If the current segment does not have sufficient space to accommodate an allocation request then a
new segment is allocated. All of the memory associated with the segments created by the allocator (i.e., in the body of
the for loop) is deallocated atomically when the memory session associated with the arena allocator is closed. This
technique combines the advantages of deterministic deallocation, provided by the MemorySession abstraction, with a more
flexible and scalable allocation scheme. It can be very useful when writing code which manages a large number of
off-heap segments.

# 不安全的内存段

So far, we have seen memory segments, memory addresses, and memory layouts. Dereference operations are only possible on
memory segments. Since a memory segment has spatial and temporal bounds, the Java runtime ensures that the memory
associated with a given segment is dereferenced safely. However, there are situations where clients might only have a
MemoryAddress instance, as is often the case when interacting with native code. To dereference a memory address, a
client has two options:

First, the client can use one of the dereference methods defined in the MemoryAddress class. These methods are unsafe
because a memory address has no spatial or temporal bounds, and thus the FFM API has no way to ensure that the memory
location being dereferenced is valid.

Alternatively, the client can unsafely turn the address into a segment via the MemorySegment::ofAddress factory. This
factory attaches fresh spatial and temporal bounds to an otherwise raw memory address in order to allow dereference
operations. The memory segment returned by this factory is unsafe: A raw memory address might be associated with a
memory region that is 10 bytes long, but the client might accidentally overestimate the size of the region and create an
unsafe memory segment that is 100 bytes long. Later, this might result in attempts to dereference memory outside the
bounds of the memory region associated with the unsafe segment, which might cause a JVM crash or, worse, result in
silent memory corruption.

Both of these options are unsafe and therefore restricted, which means their use causes warnings to be displayed at run
time (see more below).

# 查找外部函数

The first ingredient of any support for foreign functions is a mechanism to find the address of a given symbol in a
loaded native library. This capability, represented by a SymbolLookup object, is crucial for linking Java code to
foreign functions (see below). The FFM API supports three different kinds of symbol lookup objects:

SymbolLookup::libraryLookup(String, MemorySession) creates a library lookup, which locates all the symbols in a
user-specified native library. Creating the lookup object causes the library to be loaded (e.g., using dlopen()) and
associated with a MemorySession object. Closing that session causes the library to be unloaded (e.g., using dlclose()).

SymbolLookup::loaderLookup() creates a loader lookup, which locates all the symbols in all the native libraries that
have been loaded by classes in the current class loader using the System::loadLibrary and System::load methods.

Linker::defaultLookup() creates a default lookup, which locates all the symbols in libraries that are commonly used on
the OS and processor combination associated with the Linker instance.

Given a symbol lookup, a client can find a foreign function with the SymbolLookup::lookup(String) method. If the named
function is present among the symbols seen by the symbol lookup then the method returns a zero-length memory segment
whose base address points to the function's entry point. For example, the following code uses a loader lookup to load
the OpenGL library and find the address of its glGetString function:

try (MemorySession session = MemorySession.openConfined()) {   
SymbolLookup opengl = SymbolLookup.libraryLookup("libGL.so", session);
MemorySegment glVersion = opengl.lookup("glGetString").get();
...
} // libGL.so unloaded here
SymbolLookup::libraryLookup(String, MemorySession) differs from JNI’s library loading mechanism (i.e., System::
loadLibrary) in an important way. Native libraries designed to work with JNI can use JNI functions to perform Java
operations, such as object allocation or method access, which might trigger class loading. Therefore such JNI-affiliated
libraries must be associated with a class loader when they are loaded by the JVM. Then, to preserve class loader
integrity, the same JNI-affiliated library cannot be loaded from classes defined in different class loaders. In
contrast, the FFM API does not offer functions for native code to access the Java environment, and does not assume that
native libraries are designed to work with the FFM API. The native libraries loaded via SymbolLookup::libraryLookup(
String, MemorySession) are unaware that they are accessed from code running in a JVM, and make no attempt to perform
Java operations. As such, they are not tied to a particular class loader and can be (re)loaded as many times as needed
by FFM API clients in different loaders.

# 将Java代码链接到外部函数

The Linker interface is the core of how Java code interoperates with foreign code. While in this document we often refer
to interoperation between Java and C libraries, the concepts in this interface are general enough to support other
non-Java languages in future. The Linker interface enables both downcalls (calls from Java code to native code) and
upcalls (calls from native code back to Java code).

interface Linker {
MethodHandle downcallHandle(Addressable func,
FunctionDescriptor function);
MemorySegment upcallStub(MethodHandle target,
FunctionDescriptor function,
MemorySession session);
}
For downcalls, the downcallHandle method takes the address of a foreign function — typically, a MemorySegment obtained
from a library lookup — and exposes the foreign function as a downcall method handle. Later, Java code invokes the
downcall method handle by calling its invoke (or invokeExact) method, and the foreign function runs. Any arguments
passed to the method handle's invoke method are passed on to the foreign function.

For upcalls, the upcallStub method takes a method handle — typically, one which refers to a Java method, rather than a
downcall method handle — and converts it to a MemorySegment instance. Later, the memory segment is passed as an argument
when Java code invokes a downcall method handle. In effect, the memory segment serves as a function pointer. (For more
information on upcalls, see below.)

Suppose we wish to downcall from Java to the strlen function defined in the standard C library:

size_t strlen(const char *s);
Clients can link C functions using the native linker (see Linker::nativeLinker), a Linker implementation that conforms
to the ABI determined by the OS and CPU on which the JVM is running. A downcall method handle that exposes strlen can be
obtained as follows (the details of FunctionDescriptor will be described shortly):

Linker linker = Linker.nativeLinker();
MethodHandle strlen = linker.downcallHandle(
linker.defaultLookup().lookup("strlen").get(),
FunctionDescriptor.of(JAVA_LONG, ADDRESS)
);
Invoking the downcall method handle will run strlen and make its result available in Java. For the argument to strlen,
we use a helper method to convert a Java string into an off-heap memory segment (using the implicit allocator) which is
then passed by-reference:

MemorySegment str = implicitAllocator().allocateUtf8String("Hello");
long len = strlen.invoke(cString); // 5
Method handles work well for exposing foreign functions because the JVM already optimizes the invocation of method
handles all the way down to native code. When a method handle refers to a method in a class file, invoking the method
handle typically causes the target method to be JIT-compiled; subsequently, the JVM interprets the Java bytecode that
calls MethodHandle::invokeExact by transferring control to the assembly code generated for the target method. Thus, a
traditional method handle in Java targets non-Java code behind the scenes; a downcall method handle is a natural
extension that lets developers target non-Java code explicitly. Method handles also enjoy a property called signature
polymorphism which allows box-free invocation with primitive arguments. In sum, method handles let the Linker expose
foreign functions in a natural, efficient, and extensible manner.

# 描述Java中的C类型

To create a downcall method handle, the FFM API requires the client to provide a FunctionDescriptor that describes the C
parameter types and C return type of the target C function. C types are described in the FFM API by MemoryLayout objects
such as ValueLayout for scalar C types and GroupLayout for C struct types. Clients usually have MemoryLayout objects on
hand to dereference data in foreign memory, and can reuse them to obtain a FunctionDescriptor.

The FFM API also uses the FunctionDescriptor to derive the type of the downcall method handle. Every method handle is
strongly typed, which means it is stringent about the number and types of the arguments that can be passed to its
invokeExact method at run time. For example, a method handle created to take one MemoryAddress argument cannot be
invoked via invokeExact(<MemoryAddress>, <MemoryAddress>), even though invokeExact is a varargs method. The type of the
downcall method handle describes the Java signature which clients must use when invoking the downcall method handle. It
is, effectively, the Java view of the C function.

As an example, suppose a downcall method handle should expose a C function that takes a C int and returns a C long. On
Linux/x64 and macOS/x64, the C types long and int are associated with the predefined layouts JAVA_LONG and JAVA_INT
respectively, so the required FunctionDescriptor can be obtained with FunctionDescriptor.of(JAVA_LONG, JAVA_INT). The
native linker will then arrange for the type of the downcall method handle to be the Java signature int to long.

Clients must be aware of the current platform if they target C functions which use scalar types such as long, int, and
size_t. This is because the association of scalar C types with layout constants varies by platform. On Windows/x64, a C
long is associated with the JAVA_INT layout, so the required FunctionDescriptor would be FunctionDescriptor.of(JAVA_INT,
JAVA_INT) and the type of the downcall method handle would be the Java signature int to int.

As another example, suppose a downcall method handle should expose a void C function that takes a pointer. On all
platforms, a C pointer type is associated with the predefined layout ADDRESS, so the required FunctionDescriptor can be
obtained with FunctionDescriptor.ofVoid(ADDRESS). The native linker will then arrange for the type of the downcall
method handle to be the Java signature Addressable to void. Addressable is a common supertype of entities in the FFM API
that can be passed by reference, such as MemorySegment and MemoryAddress.

Clients can use C pointers without being aware of the current platform. Clients do not need to know the size of pointers
on the current platform, since the size of the ADDRESS layout is inferred from the current platform, nor do clients need
to distinguish between C pointer types such as int* and char**.

Finally, unlike JNI, the native linker supports passing structured data to foreign functions. Suppose a downcall method
handle should expose a void C function that takes a struct, described by the following layout:

MemoryLayout SYSTEMTIME = MemoryLayout.ofStruct(
JAVA_SHORT.withName("wYear"), JAVA_SHORT.withName("wMonth"),
JAVA_SHORT.withName("wDayOfWeek"), JAVA_SHORT.withName("wDay"),
JAVA_SHORT.withName("wHour"), JAVA_SHORT.withName("wMinute"),
JAVA_SHORT.withName("wSecond"), JAVA_SHORT.withName("wMilliseconds")
);
The required FunctionDescriptor can be obtained with FunctionDescriptor.ofVoid(SYSTEMTIME). The Linker will arrange for
the type of the downcall method handle to be the Java signature MemorySegment to void.

The memory layout associated with a C struct type must be a composite layout which defines the sub-layouts for all the
fields in the C struct, including any platform-dependent padding a native compiler might insert.

If a C function returns a by-value struct (not shown here) then a fresh memory segment must be allocated off-heap and
returned to the Java client. To achieve this, the method handle returned by downcallHandle requires an additional
SegmentAllocator argument which the FFM API uses to allocate a memory segment to hold the struct returned by the C
function.

As mentioned earlier, while the native linker implementation is focused on providing interoperation between Java and C
libraries, the Linker interface is language-neutral: It has no specific knowledge of how C types are defined, so clients
are responsible for obtaining suitable layout definitions for C types. This choice is deliberate, since layout
definitions for C types — whether simple scalars or complex structs — are ultimately platform-dependent, and can
therefore be mechanically generated by a tool that has an intimate understanding of the given target platform.

# 为C函数打包Java参数

A calling convention enables interoperation between different languages by specifying how code in one language invokes a
function in another language, passes arguments, and receives results. The Linker API is neutral with respect to calling
conventions, but the native linker implementation supports several calling conventions out-of-the-box: Linux/x64,
Linux/AArch64, macOS/x64, and Windows/x64. Being written in Java, it is far easier to maintain and extend than JNI,
whose calling conventions are hardwired into HotSpot's C++ code.

Consider the FunctionDescriptor obtained above for the SYSTEMTIME struct/layout. Given the calling convention of the OS
and CPU where the JVM is running, the native linker uses the FunctionDescriptor to infer how the struct's fields should
be passed to the C function when a downcall method handle is invoked with a MemorySegment argument. For one calling
convention, the native linker implementation could arrange to decompose the incoming memory segment, pass the first four
fields using general CPU registers, and pass the remaining fields on the C stack. For a different calling convention,
the native linker implementation could arrange to pass the struct indirectly by allocating a region of memory,
bulk-copying the contents of the incoming memory segment into that region, and passing a pointer to that memory region
to the C function. This lowest-level packaging of arguments happens behind the scenes, without any need for supervision
by client code.

# 上行调用

Sometimes it is useful to pass Java code as a function pointer to some foreign function. We can do that by using the
Linker support for upcalls. In this section we build, piece by piece, a more sophisticated example which demonstrates
the full power of the Linker, with full bidirectional interoperation of both code and data across the Java/native
boundary.

Consider the following function defined in the standard C library:

void qsort(void *base, size_t nmemb, size_t size,
int (*compar)(const void *, const void *));
To call qsort from Java, we first need to create a downcall method handle:

Linker linker = Linker.nativeLinker();
MethodHandle qsort = linker.downcallHandle(
linker.defaultLookup().lookup("qsort").get(),
FunctionDescriptor.ofVoid(ADDRESS, JAVA_LONG, JAVA_LONG, ADDRESS)
);
As before, we use the JAVA_LONG layout to map the C size_t type, and we use the ADDRESS layout for both the first
pointer parameter (the array pointer) and the last parameter (the function pointer).

qsort sorts the contents of an array using a custom comparator function, compar, passed as a function pointer.
Therefore, to invoke the downcall method handle we need a function pointer to pass as the last parameter to the method
handle's invokeExact method. Linker::upcallStub helps us create function pointers by using existing method handles, as
follows.

First, we write a static method in Java that compares two int values, represented indirectly as MemoryAddress objects:

class Qsort {
static int qsortCompare(MemoryAddress addr1, MemoryAddress addr2) {
return Integer.compare(addr1.get(JAVA_INT, 0), addr2.get(JAVA_INT, 0));
}
}
Second, we create a method handle pointing to the Java comparator method:

MethodHandle comparHandle
= MethodHandles.lookup()
.findStatic(Qsort.class, "qsortCompare",
MethodType.methodType(int.class,
MemoryAddress.class,
MemoryAddress.class));
Third, now that we have a method handle for our Java comparator we can create a function pointer using Linker::
upcallStub. Just as for downcalls, we describe the signature of the function pointer using a FunctionDescriptor:

MemorySegment comparFunc =
linker.upcallStub(comparHandle,
/* A Java description of a C function
implemented by a Java method! */
FunctionDescriptor.of(JAVA_INT, ADDRESS, ADDRESS),
MemorySession.openImplicit());
);
We finally have a memory address, comparFunc, which points to a stub that can be used to invoke our Java comparator
function, and so we now have all we need to invoke the qsort downcall handle:

MemorySegment array = implicitAllocator().allocateArray(
ValueLayout.JAVA_INT,
new int[] { 0, 9, 3, 4, 6, 5, 1, 8, 2, 7 });
qsort.invoke(array, 10L, ValueLayout.JAVA_INT.byteSize(), comparFunc);
int[] sorted = array.toIntArray(); // [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
This code creates an off-heap array, copies the contents of a Java array into it, and then passes the array to the qsort
handle along with the comparator function we obtained from the native linker. After the invocation, the contents of the
off-heap array will be sorted according to our comparator function, written in Java. We then extract a new Java array
from the segment, which contains the sorted elements.

# 安全

从根本上
Java 代码和本机代码之间的任何交互都可能损害 Java 平台的完整性。
链接到预编译库中的 C 函数本质上是不可靠的，因为 Java 运行时无法保证函数的签名与 Java 代码的期望相匹配。
甚至 C 库中的符号实际上是一个函数。
而且，即使链接了一个合适的函数，实际调用该函数也会导致低级故障，
例如分段错误，最终导致 VM 崩溃。
Java 运行时无法阻止此类故障，Java 代码也无法捕获此类故障。

使用 JNI 函数的本机代码尤其危险。
这样的代码可以在没有命令行标志的情况下访问JDK内部（例如，`--add-opens`），
通过使用`getStaticField`和`callVirtualMethod`等函数。
它还可以在初始化后很长时间内更改最终字段的值。
允许本机代码绕过应用于 Java 代码的检查会破坏 JDK 中的每个边界和假设。
换句话说，JNI本质上是不安全的。

不能禁用 JNI，因此，无法确保Java代码不会调用使用危险JNI函数的本机代码。
这是对平台完整性的风险，应用程序开发人员和最终用户几乎看不到，
因为这些功能的 99% 使用通常来自第三方，第四方和第五方库夹在应用程序和 JDK 之间。

大多数FFM API在设计上是安全的。
过去需要使用 JNI 和本机代码的许多场景都可以通过在 FFM API 中调用方法来实现， 这不会损害Java平台。
例如，JNI 的主要用例，灵活的内存分配，通过简单的方法支持`MemorySegment::allocateNative`，
不涉及本机代码，并且始终返回由 Java 运行时管理的内存。
一般来说，使用 FFM API 的 Java 代码不会使 JVM 崩溃。

然而，FFM API的一部分本质上是不安全的。
与链接器交互时，Java 代码可以通过指定与底层外来函数的参数类型不兼容的参数类型来请求向下调用方法句柄。
在 Java 中调用下行调用方法句柄将导致与在 JNI 中调用本机方法时可能发生的相同类型的结果（VM 崩溃或未定义的行为）。
FFM API 还可以生成不安全的段，即其空间和时间边界由用户提供且无法由 Java 运行时验证的内存段
（请参阅 `MemorySegment::ofAddress`）。

FFM API 中的不安全方法不会带来与 JNI 函数相同的风险;
例如，它们不能更改 Java 对象中最终字段的值。
另一方面，FFM API中的不安全方法很容易从Java代码中调用。
因此，在FFM API中使用不安全的方法受到限制：允许使用它们，但默认情况下，每次此类使用都会导致在运行时发出警告。
若要允许模块 M 中的代码在没有警告的情况下使用不安全的方法，在 java 命令行上指定 `--enable-native-access=M` 选项。
（使用逗号分隔的列表指定多个模块，指定 `ALL-UNNAME` 以允许对类路径上的所有代码进行无警告使用)。
当此选项存在时，任何从指定模块列表之外使用不安全的方法都将导致抛出非法调用者异常，而不是要发出的警告。
在将来的版本中，可能需要此选项才能使用不安全的方法。

我们不建议在这里限制JNI的任何方面。
仍然可以在 Java 中调用本机方法，以及用于调用不安全 JNI 函数的本机代码。
但是，我们很可能会在未来的版本中以某种方式限制 JNI。
例如，不安全的 JNI 函数（如 `newDirectByteBuffer`）可能默认禁用，就像FFM API 中的不安全方法一样。
更广泛地说，JNI 机制是如此危险，以至于我们希望库在安全和不安全操作中都更喜欢纯 Java FFM API，
以便随着时间的推移，我们可以默认禁用所有 JNI。
这与更广泛的Java路线图一致，即使平台开箱即用。
要求最终用户选择参与不安全的活动，例如破坏强封装或链接到未知代码。

我们不建议以任何方式更改`sun.misc.Unsafe`。
FFM API 对堆外内存的支持是 `malloc` 和 `free`（包装在 sun.misc.Unsafe 中）的绝佳替代方案，
即 allocateMemory、setMemory、copyMemory 和 freeMemory。
我们希望需要堆外存储的库和应用程序采用 FFM API，以便我们可以弃用并最终删除这些 `sun.misc.Unsafe` 方法。

# 选择

继续使用 `java.nio.ByteBuffer`、`sun.misc.Unsafe`、JNI 和其他第三方框架。

# 风险和假设

创建一个 API 以安全高效的方式访问外部内存是一项艰巨的任务。
由于需要在每次访问时执行前面各节中描述的空间和时间检查，
至关重要的是，JIT 编译器能够通过例如将它们提升到热循环之外来优化这些检查。
JIT 实现可能需要一些工作来确保 API 的使用与使用现有 API（如 ByteBuffer 和 Unsafe）一样高效且可优化。
JIT 实现还需要努力确保从 API 检索的本机方法句柄的使用至少与使用现有 JNI 本机方法一样高效且可优化。

# 依赖

外部函数和内存API可用于访问非易失性存储器，
已经可以通过JEP 352（非易失性映射字节缓冲区）以更通用和更有效的方式实现。

这里描述的工作可能会使后续工作能够提供一个工具，从给定本机库的头文件开始，以机械方式生成与该库互操作所需的本机方法句柄。
这将进一步减少使用 Java 原生库的开销。
